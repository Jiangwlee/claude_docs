# 使用 Claude Code 辅助开发的最佳实践总结

## Claude Code 在开发各阶段的应用

**Claude Code** 是 Anthropic 推出的命令行智能编码助手，可以贯穿开发流程的各个阶段【1†L21-L29】。以下总结它在不同环节的最佳用法：

#### 需求澄清与 PRD（产品需求文档）编写

- **头脑风暴与细化需求**：在项目启动时，可以先使用聊天模型（如 Claude Desktop 或 Gemini 模型）讨论产品想法，生成初步的 PRD【15†L264-L272】。然后将生成的 PRD 提供给 Claude Code，让其阅读并提出疑问或建议，帮助澄清需求细节。如果 Claude 提出有价值的建议，可据此更新 PRD【15†L268-L276】。通过多轮迭代，确保 PRD 明确、完整。开发者经验表明，与 AI **协作**撰写 PRD 能加快定义产品的过程，但必须由人主导需求，AI 仅作为助手【16†L101-L110】【16†L127-L135】。正如一位资深用户所言：“你需要自己掌舵，AI 只是帮你表达和完善你的愿景”【16†L99-L107】【16†L111-L118】。

- **结构化 PRD 方便 AI 理解**：将 PRD 按清晰的章节和要点编写，使其既利于人读也便于 AI 解析【4†L58-L66】【4†L82-L90】。例如，可以包含“功能概述、用户故事、验收标准、约束条件、技术规格”等清晰标段【4†L58-L66】。将每条用户故事和验收标准写成**原子且明确**的条目，避免冗长段落，以免 Claude 混淆细节【4†L72-L80】【4†L82-L90】。明确列出不可违背的约束（如技术栈限制、安全合规要求）也很重要，这样 Claude 在实现时会避开违例方案【4†L92-L100】【4†L100-L107】。下例展示了 PRD 文档的一种结构模板：

```markdown
# 项目名称
## 1. 产品简介
[在此简述产品目标和价值主张]

## 2. 目标用户
- [主要用户类型1]
- [主要用户类型2]
…

## 3. 核心功能
### 3.1 [功能1名称]
- [功能描述]
    - [子功能或细节要求]
    - ...
### 3.2 [功能2名称]
- [功能描述]
    - ...
…（后续章节包括UI设计要求、业务规则、性能/安全需求等）

```

上述模板清晰列出了产品需求的层次结构。通过这种格式，Claude 可以按照预先设计的框架填充内容，并在每轮交互后**返回当前完整的PRD版本**，同时提出需要澄清的问题【18†L389-L398】【18†L399-L407】。实践证明，**多轮迭代**才能打磨出理想的 PRD，每次都根据 AI 的输出调整和补充，直到文档满足预期【16†L225-L234】【16†L236-L243】。

- **结合 ChatPRD 实时同步**：对于多人协作或长周期项目，可使用 Anthropic 的 **ChatPRD** 工具，通过 Model Context Protocol (MCP) 将 PRD 作为 Claude Code 的**实时上下文**。Claude Code 能直接按需检索 ChatPRD 中最新的需求内容，例如 “按照 PRD 第5.1节实现设置页面”，它会自动获取PRD中对应部分【4†L172-L180】【4†L174-L182】。这样，无需手工反复复制粘贴需求，确保 Claude 始终依据最新规范进行开发【4†L165-L173】【4†L177-L185】。ChatPRD 与 `CLAUDE.md` 搭配使用，可实现需求（**What**）和实现规范（**How**）的双重约束，保证生成的代码既符合需求又遵循项目风格【4†L183-L191】。

#### 代码编写与迭代

- **自动获取项目上下文**：Claude Code 可自动载入**当前打开文件、项目索引**以及 `CLAUDE.md` 中的信息作为上下文【4†L195-L203】。因此在开始编码前，先打开相关源文件或提供必要的设计文档，让 Claude 有充分背景。你也可以直接让 Claude “阅读”某文件或链接，以便它了解现有代码或库的用法，然后明确告知**暂时不要编写代码**【8†L228-L236】。例如：“请阅读 `logging.py`，理解日志模块如何设计，但**暂时不要生成代码**。” 这一步相当于让 Claude 先**探索**现有代码和资料，以防止盲目动手【8†L228-L236】。如果问题复杂，还可提示 Claude 使用**子代理**来分步调查细节，从而节省主会话的上下文长度【8†L230-L238】。

- **制定计划再编码**：经过探索后，要求 Claude **生成解决方案的计划**而不是直接上代码。这一步可以使用提示语如“`think`”或“`think harder`”触发 Claude 进入扩展思考模式，让它深度权衡方案【8†L235-L243】。Anthropic 提供了特殊关键词：“think” < “think hard” < “think harder” < “ultrathink”，逐级增加思考预算【8†L236-L244】。你可以审查 Claude 给出的计划，必要时让它修改，直到方案看起来可靠，再进入实现阶段【8†L242-L250】【8†L252-L255】。这一**计划-审阅**步骤对复杂任务尤其关键，可显著提高最终代码质量【8†L251-L258】。

- **分块实现，逐步迭代**：按照确认的计划，让 Claude **逐步实现**代码。可将大任务拆解为一系列子任务，让 Claude 逐个完成并验证。例如，Anthropic 工程师常用**测试驱动开发 (TDD)** 流程【8†L259-L268】：先让 Claude 根据需求编写测试用例，然后运行测试（Claude 可以调用测试命令）确认失败，再让它编写实现代码直到测试通过【8†L263-L271】【8†L269-L277】。这种方法确保 Claude 明确开发目标，并通过不断运行测试得到即时反馈【8†L270-L277】【8†L278-L281】。实践中 Claude 通常需要几轮“写代码->运行测试->修正代码”才能通过所有测试，在此过程中你应强调**不允许修改测试**，只改进代码，直到符合要求【8†L269-L277】。除了测试驱动，也可以提供**期望的输出或界面截图**让 Claude 对照迭代【8†L285-L293】。例如，在前端开发中给 Claude 提供设计稿图像，让它反复调整生成的UI代码，直到截图视觉效果与设计图匹配【8†L287-L295】。

- **自动提交和文档更新**：当某个子任务完成后，可让 Claude **提交代码并更新文档**。Claude Code 深度集成了 Git 和 GitHub 操作：它能理解“pr”是创建 Pull Request，并自动根据 diff 生成详尽的提交信息【6†L353-L361】【6†L355-L363】。你可以让 Claude 在实现完功能后执行 `git commit` 并创建 PR，甚至更新README或CHANGELOG说明改动【8†L245-L253】。Claude 能够总结最近的更改记录来生成上下文丰富的 commit 描述【6†L343-L347】。通过这些自动化步骤，开发者可以将繁琐的提交、开 PR 工作交给 Claude 完成【6†L353-L361】【6†L357-L363】。

- **多轮对话完善代码**：将 Claude Code 当作**对话式编程伙伴**，及时审阅它输出的代码并给予反馈。Claude Code 支持在对话中断后继续：“按 `Esc` 可随时打断 Claude 的行动，保留上下文以便你插入新的指令纠正方向”【6†L449-L457】；连按两次 `Esc` 可以**回滚对话历史**，编辑之前的提示并重新引导 Claude【6†L451-L459】。例如，你让 Claude 添加一个日期选择器组件，第一次生成的代码不符预期，你可以打断并说明具体修改意见，然后让它基于最新指令重试。这种**人机互动迭代**往往比一次性让 Claude 自行完成效果更好【6†L439-L447】【6†L441-L449】。

#### 代码评审与改进

- **自动修复 PR 评论**：当有人在 Pull Request 上留下代码审查意见时，可以直接告诉 Claude Code “根据 PR 审核意见修改代码”。Claude 将根据评论内容自动定位代码并尝试修复，然后将更改推送回 PR 分支【6†L355-L363】。对于简单的改进建议（如重命名变量、修正拼写），Claude 往往能一次性完成修改并提交，从而**加速审阅反馈的落地**【6†L355-L363】。

- **AI 代码审查**：Claude 不仅能写代码，也能充当智能审查助手。它可在无需额外工具的情况下执行主观的代码审查，发现传统 Lint 工具找不到的问题，例如拼写错误、过时注释、误导性的函数命名等【14†L515-L523】。你可以让 Claude 阅读某个文件或整个 PR 的 diff，并**给出评审意见**，包括潜在错误、风格改进点等【14†L517-L524】。由于 Claude 理解上下文能力强，它的审查反馈往往比静态分析更全面。

- **双Claude协同审核**：一个有效模式是**多代理协作**：使用一个 Claude 实例编写代码，然后启动第二个 Claude 来审查第一个 Claude 的成果【14†L526-L534】。具体流程为：(1) 用 Claude A 生成代码；(2) 重置上下文或在新终端启动 Claude B；(3) 让 Claude B 查看 Claude A 写的代码并给出审查/测试意见【14†L531-L539】；(4) 再启动 Claude C（或清空 Claude A 的上下文）读取代码和审查反馈；(5) 让 Claude根据反馈编辑代码【14†L532-L540】【14†L533-L538】。这种将**编写**和**审查**分离的做法，类似于两位工程师互相检查，往往比单一上下文里既当作者又当审查者的效果更好【14†L542-L545】。不少用户也让 Claude 相互“对话”，一个生成测试用例，另一个编写通过测试的代码，以提高代码正确性【14†L538-L542】。

- **代码库问答与知识传承**：在 Code Review 或日常开发中，如果对现有代码有疑问，可以直接问 Claude Code，例如“日志模块是如何工作的？”“为什么这里调用了 foo() 而不是 bar()？”Claude 会在整个代码库中搜索相关实现和注释，给出详尽解答【8†L319-L327】。Anthropic 工程团队反馈，这已成为**新成员熟悉代码**的核心方式之一，大幅减少了老工程师在培训新人上的负担【8†L327-L334】。Claude Code 可以被视为项目的“活文档”和顾问。

#### 测试与验证

- **自动生成测试**：Claude Code 善于根据代码和需求生成测试用例。你可以要求 Claude “为 X 模块编写全面的单元测试”，并提供功能描述或验收标准作为参考。它会产出相应测试代码，然后你可以让 Claude 执行测试（例如运行 `npm test` 或 `pytest`），观察哪些测试失败【8†L263-L271】【8†L267-L274】。利用 Claude 自动化测试，可以快速建立起回归测试集。

- **测试驱动开发 (TDD)**：如前文所述，推荐采取 TDD 流程【8†L259-L268】：先让 Claude 根据需求写测试（并明确说明此阶段**不需实现功能**，以防 Claude 为通过测试偷跑实现【8†L263-L271】），再运行测试验证失败。然后引导 Claude 编写实现直到测试通过【8†L269-L277】。在实现过程中可提示 Claude “不要硬编码通过测试，而应实现对所有有效输入都正确的通用方案”，以免它过度拟合当前测试用例【36†L238-L246】。Anthropic 建议在提示中加入类似说明：“**务必实现通用算法，而非仅针对测试用例的特定逻辑**”【36†L238-L246】。另外，可以启用**子代理**验证，即让另一个 Claude 模拟更多输入或审查实现逻辑，检查是否仅适配了测试而非真正解决问题【14†L539-L542】。

- **持续集成与 Headless 模式**：Claude Code 提供无交互的 *headless* 模式，可用于 CI/CD 流程。例如，可在 CI 中触发 Claude 自动检查每次代码变更的测试结果，或根据Issue描述生成解决方案草案【14†L510-L518】【14†L588-L596】。使用 `claude -p "<prompt>"` 可以在脚本中调用 Claude Code，并通过 JSON 输出结果，方便进一步自动化处理【14†L604-L612】。这一能力允许在测试失败时自动生成修复补丁，在Issue创建时自动提供初步分析等。借助Claude Code自动化基础工作，开发团队可以将精力更多放在疑难问题和逻辑设计上。

## Claude Code 上下文信息管理

Claude Code 擅长利用丰富的上下文，但上下文窗口是有限的，因此**有效管理上下文**至关重要【6†L462-L470】。以下是提高 Claude 上下文理解的技巧：

- **CLAUDE.md 提供持久背景**：在项目根目录创建一个特殊的 `CLAUDE.md` 文件。Claude Code 每次启动对话时会自动将其中内容作为上下文的一部分加载【1†L51-L59】。你可以在此文件中写入项目的关键信息，例如常用命令、代码风格规范、测试说明、项目中特有的警告事项等【1†L53-L61】。这相当于给 Claude 提供**项目手册**，让它对你的项目约定有先验认知【24†L539-L547】。`CLAUDE.md` **越完善，Claude 每次就越少需要重复从代码中“猜”这些背景**（例如构建命令叫什么、代码风格如何），从而减少不必要的文件扫描，提高响应效率【24†L539-L547】【24†L540-L543】。

- **上下文来源优先级**：Claude Code主要从三类来源获取上下文【4†L195-L203】：**当前打开的文件**（编辑器中可见的文件内容）、**已索引的项目文件**（Claude Code 对整个代码库建立的索引，用于按需搜索）、**外部文档**（通过 MCP 提供的资料，如 PRD、设计文档等）。为增强 Claude 对当前任务的理解，确保**将相关文件打开**（或引用文件路径让 Claude 读取【6†L426-L434】），并提供所需的文档链接或让 Claude 运行命令获取数据【6†L433-L441】【6†L485-L493】。例如，在调试问题时，可以执行 `cat error.log | claude` 将日志内容直接管道传给 Claude【6†L485-L493】。又如进行 UI 开发时，将设计稿截图粘贴给 Claude 参考【6†L411-L420】。通过明确指示 Claude 关注**指定资源**，可防止它被无关上下文干扰【6†L462-L470】。

- **拆分长对话，聚焦当前任务**：随着对话推进，Claude 的上下文可能充满过时或无关的信息，影响后续性能【6†L462-L470】。Anthropic 建议**频繁使用 `/clear` 重置对话**，开始新的上下文窗口专注当前任务【6†L462-L470】。清空上下文后，如果需要引用前文内容，可让 Claude **读取之前的产出**（例如让它打开先前生成的文件或日志）或利用持久文件（如任务清单）重新导入关键信息。很多用户会维护一个 `TASKS.md` 来记录当前任务列表和进度，每完成一项由 Claude 勾选标记【15†L271-L279】。这样在 `/clear` 后，可以让 Claude 打开 `TASKS.md` 和变更记录，以快速恢复上下文【15†L293-L299】。一位用户分享的经验是：“通过 `TASKS.md` 和 `CHANGELOG.md` 作为回忆载体，我可以随时清空对话，然后让 Claude 读取这些文件找回上下文”【15†L291-L299】。因此，养成**阶段性清理上下文**、用简明文档跟踪进展的习惯，有助于 Claude 始终聚焦当前需求并减少遗忘重要细节的风险。

- **分片多实例并行**：对于大型项目或多任务并行开发，可以启动**多个 Claude Code 实例**，每个专注不同子目录或分支。Claude 支持在同一IDE中开多个终端分别运行，在不同项目路径启动的实例会自动加载各自目录下的 `CLAUDE.md`【24†L628-L636】。Anthropic 工程师常用 *git worktree* 创建同一仓库的多个工作副本，在每个副本目录开启一个 Claude 实例处理不同任务【14†L549-L558】【14†L565-L574】。由于每个实例有独立上下文，互不干扰，这样可以同时进行多项开发，加快迭代速度【14†L565-L573】【14†L567-L575】。务必在并行作业完成后合并变更并清理临时工作树【14†L579-L587】。

- **权限管理**：Claude Code 执行可能更改系统的操作时会请求许可，例如写文件、执行 Shell 命令等【1†L123-L131】。为避免频繁打断，你可以在开始会话时使用 `/permissions` 命令配置**白名单**，预先允许安全的操作（比如允许编辑文件，或特定 `git` 命令）【1†L131-L139】。或者直接以 `claude --dangerously-skip-permissions` 模式启动，让 Claude 无需确认就连续执行所有指令【22†L29-L37】。需注意跳过权限检查有风险，建议仅在隔离环境或对Claude完全信任时使用【8†L302-L310】【8†L312-L320】。通过适当的权限配置，可以减少人为干预，让 Claude 在上下文中**流畅地**完成连续的操作步骤。

## AI Memory 的组织与管理

Claude Code 提供了**AI记忆功能**，主要形式就是上述的 `CLAUDE.md` 文件和相关机制，用于在对话之外存储长期信息。有效地组织和维护这个“记忆”可以显著提升 Claude 的上下文理解和产出一致性。以下是管理 AI Memory 的要点：

- **写入适合的内容**：`CLAUDE.md` 中的内容相当于对 Claude 的“长期记忆”提示，最好包含**项目最重要的不变信息**【1†L53-L61】。例如：
  - 常用的构建/运行命令（如如何启动项目、运行测试等)【1†L55-L63】  
  - 项目编码规范和风格指南（命名约定、代码格式、架构约定等)【1†L55-L63】  
  - 测试标准和要求（比如“所有新组件必须附带 Jest 测试”【4†L133-L139】）  
  - 项目约定的工具/库使用方法（例如“前端一律使用 React 18 + TypeScript”【4†L143-L150】）  
  - 团队协作流程（如分支命名规则、代码审核流程）  
  - 特定于项目的坑或警告（如“某模块有已知内存泄漏，慎用”）等。  

  这些信息应当**简明扼要**，以清单或要点形式呈现，便于扫描【4†L131-L139】。避免长篇大论的说明，Claude 更擅长理解**精炼的指令**而非冗长文档【4†L131-L139】【1†L65-L73】。下例是一个 `CLAUDE.md` 片段示例：

  ```markdown
  # Bash Commands  
  - npm run build：构建项目  
  - npm run typecheck：运行类型检查  

  # Code Style  
  - 使用 ES Module 语法 (`import/export`)，避免使用 CommonJS (`require`)【1†L71-L75】  
  - 尽量使用解构导入，例如 `import { foo } from 'bar'`【1†L71-L75】  

  # Workflow  
  - 进行一系列代码修改后请务必运行 `npm run typecheck`  
  - 测试尽量按需单独运行，而非动辄跑完整测试集  
  ```【1†L67-L75】

  可以将 `CLAUDE.md` 文件置于仓库根目录（并加入版本控制以便团队共享），或者放在 `~/.claude/CLAUDE.md` 作为全局记忆，甚至在各子模块目录放置专门的 CLAUDE.md 来存储局部规则【1†L83-L92】。Claude Code 会自动按层级合并这些记忆，其中**离当前工作目录最近**的 CLAUDE.md 优先级最高【24†L628-L636】。通过合理规划，既能定义全局统一规范，又能在局部覆盖特殊约定。

- **持续更新与优化**：AI Memory 不是一成不变的，应该**随着项目演进不断迭代**。当你发现 Claude 对某些指令理解有偏差，或团队更新了编码规范时，及时在 `CLAUDE.md` 中反映这些变化【4†L135-L139】。**避免过期信息**留在 memory 中，以免造成混乱【4†L135-L139】。Claude Code 提供便捷手段更新记忆：在对话中输入 `#` 开头的指令，会将这条指令自动追加到相关的 CLAUDE.md 文件中【1†L109-L117】。例如，在对话中输入「`# 今后所有 API 调用都应使用新的 HttpClient 库`」，Claude 会将这句话添加到项目的 CLAUDE.md 里，作为后续对话的参考记忆【1†L109-L117】。许多工程师频繁使用此方法，将临时有用的信息巩固为长期知识，并将更新后的 CLAUDE.md 提交到版本库与团队共享【1†L109-L117】。另外，Anthropic 提供了**Prompt Improver**等工具，可以对 CLAUDE.md 内容润色，增强指令的清晰度和权重（例如加上**“IMPORTANT”**强调必须遵守）【1†L113-L117】。

- **划分共享记忆与个人记忆**：有些偏好或配置可能只适用于你个人，而不适合放入团队共享的 CLAUDE.md。这种情况下，可以使用 `CLAUDE.local.md` 文件（添加到 .gitignore 中）存放个人记忆，如你本地的路径配置、临时实验性提示等【1†L85-L93】。Claude Code 会自动加载 `CLAUDE.local.md` 内容，但不会将其提交仓库。类似地，放在用户主目录的全局 CLAUDE.md 适用于你所有项目的通用偏好【1†L95-L100】。通过**区分公共与私有记忆**，既能让团队共享最佳实践，又允许个人灵活定制而不影响他人【24†L632-L637】。

- **提升效率与一致性**：良好的 memory 运用可以极大提高开发效率和输出质量：当 Claude Code 有了一份准确的“项目圣经”后，它能更严格地遵循既定规范，减少风格走偏或不符合团队约定的产出【4†L125-L134】【4†L143-L151】。例如，CLAUDE.md 中规定了 UI 组件应使用内部组件库的按钮，那么 Claude 生成代码时就会自觉引入 `<Button>` 而非原生 `<button>`【4†L133-L140】。又如规定“每新增组件都需附带测试”，Claude 在生成代码时会自动连同测试文件一起给出【4†L135-L143】。这些记忆让 AI 更深入地**理解项目背景**，如同一个资深团队成员般工作。此外，由于 memory 文件在不同会话间持久存在，哪怕你隔几天重启 Claude Code，先前录入的项目知识仍在，不必每次从零向 AI 解释背景，从而保持连贯的上下文理解，节省大量时间。

## Claude Code 提示词编写技巧和模板

高质量的输出源于高质量的提示。Claude Code 尽管功能强大，但并非读心术，需通过**精心编写的 prompt（提示词）**来引导。以下汇总了提升 Claude Code 输出质量的提示技巧和模板：

- **明确具体，避免模糊**：提问或指示务必清晰且具体，尽量消除歧义【34†L69-L77】【34†L77-L85】。Claude 对模糊描述会给出同样模糊的回答；而精确的需求有助于其生成有用结果【34†L75-L83】【34†L87-L95】。不要只说“优化我的网站”，而要具体到**哪个方面**、**衡量标准**是什么，例如：“请生成 JavaScript 代码，实现图片懒加载来提升电商产品页的首屏加载速度”【34†L77-L85】【34†L79-L87】。再如，不要问“怎样让界面更现代”，而应指明**现代的含义**：“使用 CSS Grid 实现卡片式布局，卡片带有细阴影和圆角，以体现现代风格”【34†L81-L88】。总之，用**客观可检验的语言**描述预期结果——包括涉及的技术、具体功能点、性能指标等——Claude 才能对准靶心输出。

- **提供充分的背景信息**：就像对新人工程师下任务需要先讲背景一样，给 Claude 的提示也应提供必要上下文【34†L88-L96】【34†L95-L99】。比如让它写一个输入验证函数，起码要告诉它**使用的框架/库、具体验证规则**等：“我在用 React+Formik 做注册表单，需要一个 Yup 验证规则：密码至少8字符，且含大小写字母、数字和特殊符号”【34†L88-L96】【34†L89-L97】。再如请求修复一个 bug，应该附上相关代码片段和出错信息，而不仅是抽象地问“如何修复这个错误”【36†L179-L187】。Claude 会将你提供的资料视作**上下文语料**，这能大大提高回答的准确度和针对性。切记，缺少背景的请求往往会得到隔靴搔痒的结果【34†L95-L99】。

- **避免礼貌遣词，直接下指令**：“请帮我…”、“能否协助…” 这类礼貌说法在人际交流中友好，但对 AI 提示却可能**适得其反**【34†L43-L50】【34†L47-L55】。根据官方文档和社区经验，使用“帮忙 (help)、请 (please)、尝试 (try)”等词，会使 Claude 倾向于给出**宽泛的帮助性回答**，而非严格遵循指令【34†L47-L55】【34†L58-L66】。原因在于这类词将 Claude 模型引导到“乐于助人”的模式，优先快速满足请求而非仔细遵循细节【34†L49-L57】【34†L58-L66】。因此，撰写提示时语气可以直截了当，例如：“生成 Python 代码实现…。” 而不用 “能帮我生成…吗？”【34†L63-L66】。事实证明，对 AI 不必客气，清晰的祈使句反而更有效。

- **一次只让 Claude 做一件事**：**切忌**在单个提示里罗列多个不相关任务，这会让 Claude 无所适从【36†L147-L155】。例如，不要一条指令里要求“创建数据库Schema、编写后端路由、再生成前端HTML模板”，否则 Claude 可能混淆步骤、顾此失彼【36†L147-L155】【36†L152-L160】。正确做法是**分步拆解**【36†L156-L164】：首先让它完成第一步（如设计数据库表）；确认满意后，再提示进行第二步（编写 Flask 路由，传入上一步结果作为上下文）；然后第三步（生成模板）。每步完成后都可以让 Claude 展示或执行结果，确保无误再进行下一步【36†L156-L164】。虽然分步感觉麻烦，但实际更高效——一步一请求不仅便于检查和**及时纠偏**，最终完成的速度反而更快【36†L162-L168】。总而言之，**一条Prompt聚焦一个目标**，逐条攻克。

- **正面描述期望，少用否定**：人们有时喜欢通过说明“不需要什么”来避免歧义，但 Claude 可能会对**否定指令**反应不佳【34†L107-L115】【34†L117-L125】。例如与其说“不要在响应中包含任何Markdown”，不如直接说“请以纯文本段落形式回答”【34†L115-L123】。与其提示“代码里不要出现全局变量”，可以改为“请使用函数参数传递数据，不使用任何全局变量”。Claude 往往会**过度关注**你让它避免的东西，反而可能忽略积极指令【34†L109-L117】。用正向、具体的描述替代模糊的禁止，可以给 Claude 一个清晰的创作方向【34†L117-L124】。同样地，比起“别用不安全的写法”，明确要求“请使用参数化查询防止 SQL 注入”等**肯定要求**效果更佳【34†L119-L127】。

- **使用主动语态和确定性措辞**：提示中的语言风格也会影响 Claude 的理解。应尽量使用主动语态和肯定句，而避免被动和模棱两可的表述【34†L129-L137】。例如，将“需要创建一个按钮，被点击时会弹出对话框”改为“创建一个按钮（文本为‘Show Details’），用户点击时弹出ID为`details-modal`的对话框”【34†L132-L139】。又如避免使用“可能、也许”等犹豫词汇，直接表述需求。【34†L139-L142】。明确肯定的语气会使 Claude 更坚定地执行指令，而不是拿不准你的意图。

- **指定输出格式和风格**：如果对输出格式有要求，一定要在提示中**显式说明**，否则 Claude 可能采用默认的冗长格式【36†L189-L198】。例如：
  - 希望输出代码，则说“请给出完整的 Python 文件代码”或“输出内容仅包含代码片段，不要额外解释”【36†L193-L200】。
  - 希望结构化数据，则指明“结果请以 JSON 对象形式给出，字段包括…”。 
  - 多段内容则可要求使用特定标记隔开，例如“用 `<section>` 标签分隔不同部分”或使用 Markdown 标题等。Claude 会据此调整输出，减少你事后编辑整理的工作【36†L193-L200】。另外提示的语气风格往往会体现在回答中——你用正式语气提出，它倾向于正式措辞回应；如果语气轻松，Claude 回答也更平易近人【36†L199-L204】。可根据场景需要调整提示语气，从而控制 Claude 输出的风格一致性。

- **鼓励思考链与检查**：对于复杂任务，可以在提示中让 Claude 展开**思考过程**（Chain-of-Thought），或在最终回答前**列出计划**。Anthropic 建议使用 XML 标签等将思考与答案分隔，例如 `<thinking>...</thinking>` 包含推理过程，`<answer>...</answer>` 给出最后结果【26†L179-L188】。在 Claude Code 场景，也可以直接提示：“在给出最终代码前，先阐述思路，并在我确认后再生成代码”。通过这种多步交流，让 Claude 先输出计划供你审核，再执行代码生成，可显著降低错误率【6†L449-L457】【8†L242-L250】。另外，鼓励 Claude 在完成任务后**自我检查**：如提示“请检查代码是否覆盖了所有验收标准”或“请确认解决方案对任意有效输入都适用”，可以让 Claude 更严谨地核对自身输出，与人review类似【36†L236-L245】。

- **利用提示模板和示例**：社区中已有不少成熟的提示模板，可以借鉴来提高 Claude 的表现。例如 **Nathan Onn** 提供了一套从需求到实现的6步提示体系，其中PRD生成、技术设计、实现、测试各有模板【18†L411-L419】。也有开发者创建自定义的 **/commands** 文件，把常用提示做成快捷命令，例如前述 Builder.io 团队将“生成测试”做成 `/test` 命令，内容是写在 `.claude/commands/test.md` 中的一系列自然语言指令【24†L599-L607】【24†L605-L613】。Claude Code 读取该命令文件，就能按照预定义格式输出结果。Anthropic 官方也建议充分使用 **Prompt Templates** 和 **Prompt Generator** 工具，在Anthropic Console里生成初稿提示，然后不断让 **Prompt Improver** 打磨【1†L115-L118】。总之，**善用模板**能帮我们快速构造高质量提示，同时保持不同场景下提示的一致性和重复利用。

- **使用 XML 标签分隔信息**：Anthropic 明确推荐用 **XML 样式标签**组织复杂提示【26†L151-L159】。通过 `<context>...</context>`、`<instructions>...</instructions>`、`<example>...</example>` 等标签，将提示中的背景资料、具体指令、示例等部分划分开【26†L155-L163】。这可以防止 Claude 将示例和指令混为一谈，并提高提示的可读性和可维护性【26†L155-L164】【26†L163-L171】。标签名称不必是固定的，但要**自解释**其内容，如 `<requirement>` 包含需求描述，`<code_snippet>` 包含代码片段等【26†L171-L178】。使用 XML 标签还能方便地提取 Claude 输出中的对应部分，利于后处理【26†L167-L174】【26†L169-L177】。许多高阶用户已经实践了这一技巧，反馈模型对结构化提示响应更准确，特别是在长上下文或多文档场景下【25†L15-L23】。

- **及时审阅并迭代提示**：拿到 Claude 的回复后，不要盲目接受，而应像审阅人一样仔细检查【16†L200-L208】。如果有偏差，明确告诉 Claude 哪部分不符合预期、需要增删哪些内容。然后**迭代修改提示**，这可能意味着重述需求、加入更具体的约束，或使用 `/clear` 清除干扰因素重新提问。一开始很少能用一个完美提示直接到位，通过**逐步试验和改进**，才能逼近理想输出【16†L226-L234】【16†L236-L243】。尤其针对复杂文档（如 PRD 或技术方案），首轮生成往往只是基础版本，需要多次来回补充细节、剔除不需要的部分，最终才达到令人满意的完整度【16†L229-L238】【16†L235-L243】。记住：与其期待 AI 一次搞定，不如把它当成**可以反复交互的合作伙伴**，通过你的引导不断靠近目标。

最后，持续从社区获取经验也是有益的。Anthropic 官方和早期用户经常在 Twitter、Reddit 等分享 Claude Code 的使用心得和教程。例如，有开发者总结出一些**不宜出现在提示中的词**（如上文提到的“help”、“please”等)【34†L47-L55】；还有人专门整理了**Claude 提示工程的12条技巧清单**，涵盖从使用XML标签、直接明确到为Claude设定角色等方面【25†L39-L46】。保持学习和尝试，结合以上原则不断调整，才能最大化发挥 Claude Code 在开发中的助力作用，让 AI 成为开发流程中高效而可靠的伙伴。

**参考资料：**

1. Anthropic工程博客: *Claude Code: Best practices for agentic coding*【1†L21-L29】【1†L53-L61】等  
2. ChatPRD 博客: *Best Practices for Using PRDs with Claude Code*【4†L58-L66】【4†L82-L90】等  
3. Box开发者博客: *Build Faster and Smarter with Claude Code*【10†L91-L99】【10†L125-L134】等  
4. Reddit 讨论: *Claude Code: What do you do when starting a brand new project?*【15†L264-L272】【15†L293-L301】  
5. Nathan Onn 博客: *Stop Asking Claude Code to “Build Me an App”*【16†L101-L110】【16†L225-L234】等  
6. Arsturn 博客: *Claude Prompting Guide: Words to Avoid for Better Code*【34†L47-L55】【34†L75-L84】等  
7. Builder.io 博客: *How I use Claude Code (+ my best tips)*【24†L539-L547】【24†L626-L635】  
8. Anthropic 文档: *Prompt engineering & Claude 4 best practices*【26†L155-L164】【36†L152-L160】等
